// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb_metadata.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "pb_metadata.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace stream_switch {

namespace {

const ::google::protobuf::Descriptor* ProtoSubStreamInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProtoSubStreamInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProtoMetaReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProtoMetaReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProtoMetaRep_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProtoMetaRep_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ProtoPlayType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ProtoSubStreamMediaType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ProtoSubStreamDirectionType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_pb_5fmetadata_2eproto() {
  protobuf_AddDesc_pb_5fmetadata_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "pb_metadata.proto");
  GOOGLE_CHECK(file != NULL);
  ProtoSubStreamInfo_descriptor_ = file->message_type(0);
  static const int ProtoSubStreamInfo_offsets_[17] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, media_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, codec_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, extra_data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, fps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, gov_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, samples_per_second_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, channels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, bits_per_sample_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, sampele_per_frame_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, fone_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, font_type_),
  };
  ProtoSubStreamInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProtoSubStreamInfo_descriptor_,
      ProtoSubStreamInfo::default_instance_,
      ProtoSubStreamInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoSubStreamInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProtoSubStreamInfo));
  ProtoMetaReq_descriptor_ = file->message_type(1);
  static const int ProtoMetaReq_offsets_[1] = {
  };
  ProtoMetaReq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProtoMetaReq_descriptor_,
      ProtoMetaReq::default_instance_,
      ProtoMetaReq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaReq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaReq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProtoMetaReq));
  ProtoMetaRep_descriptor_ = file->message_type(2);
  static const int ProtoMetaRep_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, play_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, source_proto_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, ssrc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, bps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, sub_streams_),
  };
  ProtoMetaRep_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProtoMetaRep_descriptor_,
      ProtoMetaRep::default_instance_,
      ProtoMetaRep_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProtoMetaRep, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProtoMetaRep));
  ProtoPlayType_descriptor_ = file->enum_type(0);
  ProtoSubStreamMediaType_descriptor_ = file->enum_type(1);
  ProtoSubStreamDirectionType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_pb_5fmetadata_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProtoSubStreamInfo_descriptor_, &ProtoSubStreamInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProtoMetaReq_descriptor_, &ProtoMetaReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProtoMetaRep_descriptor_, &ProtoMetaRep::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_pb_5fmetadata_2eproto() {
  delete ProtoSubStreamInfo::default_instance_;
  delete ProtoSubStreamInfo_reflection_;
  delete ProtoSubStreamInfo::_default_codec_name_;
  delete ProtoMetaReq::default_instance_;
  delete ProtoMetaReq_reflection_;
  delete ProtoMetaRep::default_instance_;
  delete ProtoMetaRep_reflection_;
}

void protobuf_AddDesc_pb_5fmetadata_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021pb_metadata.proto\022\rstream_switch\"\243\003\n\022P"
    "rotoSubStreamInfo\022\r\n\005index\030\001 \001(\005\022:\n\nmedi"
    "a_type\030\002 \001(\0162&.stream_switch.ProtoSubStr"
    "eamMediaType\022\030\n\ncodec_name\030\003 \001(\t:\004h264\022="
    "\n\tdirection\030\004 \001(\0162*.stream_switch.ProtoS"
    "ubStreamDirectionType\022\022\n\nextra_data\030\n \001("
    "\014\022\016\n\006height\030\024 \001(\r\022\r\n\005width\030\025 \001(\r\022\013\n\003fps\030"
    "\026 \001(\r\022\013\n\003gov\030\027 \001(\r\022\032\n\022samples_per_second"
    "\030\036 \001(\r\022\020\n\010channels\030\037 \001(\r\022\027\n\017bits_per_sam"
    "ple\030  \001(\r\022\031\n\021sampele_per_frame\030! \001(\r\022\t\n\001"
    "x\030( \001(\r\022\t\n\001y\030) \001(\r\022\021\n\tfone_size\030* \001(\r\022\021\n"
    "\tfont_type\030+ \001(\t\"\016\n\014ProtoMetaReq\"\250\001\n\014Pro"
    "toMetaRep\022/\n\tplay_type\030\001 \001(\0162\034.stream_sw"
    "itch.ProtoPlayType\022\024\n\014source_proto\030\002 \001(\t"
    "\022\014\n\004ssrc\030\003 \001(\r\022\013\n\003bps\030\004 \001(\r\0226\n\013sub_strea"
    "ms\030@ \003(\0132!.stream_switch.ProtoSubStreamI"
    "nfo*E\n\rProtoPlayType\022\030\n\024PROTO_PLAY_TYPE_"
    "LIVE\020\000\022\032\n\026PROTO_PLAY_TYPE_REPLAY\020\001*\266\001\n\027P"
    "rotoSubStreamMediaType\022%\n!PROTO_SUB_STRE"
    "AM_MEIDA_TYPE_VIDEO\020\000\022%\n!PROTO_SUB_STREA"
    "M_MEIDA_TYPE_AUDIO\020\001\022$\n PROTO_SUB_STREAM"
    "_MEIDA_TYPE_TEXT\020\002\022\'\n#PROTO_SUB_STREAM_M"
    "EIDA_TYPE_PRIVATE\020\003*n\n\033ProtoSubStreamDir"
    "ectionType\022\'\n#PROTO_SUB_STREAM_DIRECTION"
    "_OUTBOUND\020\000\022&\n\"PROTO_SUB_STREAM_DIRECTIO"
    "N_INBOUND\020\001", 1011);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "pb_metadata.proto", &protobuf_RegisterTypes);
  ProtoSubStreamInfo::_default_codec_name_ =
      new ::std::string("h264", 4);
  ProtoSubStreamInfo::default_instance_ = new ProtoSubStreamInfo();
  ProtoMetaReq::default_instance_ = new ProtoMetaReq();
  ProtoMetaRep::default_instance_ = new ProtoMetaRep();
  ProtoSubStreamInfo::default_instance_->InitAsDefaultInstance();
  ProtoMetaReq::default_instance_->InitAsDefaultInstance();
  ProtoMetaRep::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_pb_5fmetadata_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_pb_5fmetadata_2eproto {
  StaticDescriptorInitializer_pb_5fmetadata_2eproto() {
    protobuf_AddDesc_pb_5fmetadata_2eproto();
  }
} static_descriptor_initializer_pb_5fmetadata_2eproto_;
const ::google::protobuf::EnumDescriptor* ProtoPlayType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtoPlayType_descriptor_;
}
bool ProtoPlayType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ProtoSubStreamMediaType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtoSubStreamMediaType_descriptor_;
}
bool ProtoSubStreamMediaType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ProtoSubStreamDirectionType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtoSubStreamDirectionType_descriptor_;
}
bool ProtoSubStreamDirectionType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

::std::string* ProtoSubStreamInfo::_default_codec_name_ = NULL;
#ifndef _MSC_VER
const int ProtoSubStreamInfo::kIndexFieldNumber;
const int ProtoSubStreamInfo::kMediaTypeFieldNumber;
const int ProtoSubStreamInfo::kCodecNameFieldNumber;
const int ProtoSubStreamInfo::kDirectionFieldNumber;
const int ProtoSubStreamInfo::kExtraDataFieldNumber;
const int ProtoSubStreamInfo::kHeightFieldNumber;
const int ProtoSubStreamInfo::kWidthFieldNumber;
const int ProtoSubStreamInfo::kFpsFieldNumber;
const int ProtoSubStreamInfo::kGovFieldNumber;
const int ProtoSubStreamInfo::kSamplesPerSecondFieldNumber;
const int ProtoSubStreamInfo::kChannelsFieldNumber;
const int ProtoSubStreamInfo::kBitsPerSampleFieldNumber;
const int ProtoSubStreamInfo::kSampelePerFrameFieldNumber;
const int ProtoSubStreamInfo::kXFieldNumber;
const int ProtoSubStreamInfo::kYFieldNumber;
const int ProtoSubStreamInfo::kFoneSizeFieldNumber;
const int ProtoSubStreamInfo::kFontTypeFieldNumber;
#endif  // !_MSC_VER

ProtoSubStreamInfo::ProtoSubStreamInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stream_switch.ProtoSubStreamInfo)
}

void ProtoSubStreamInfo::InitAsDefaultInstance() {
}

ProtoSubStreamInfo::ProtoSubStreamInfo(const ProtoSubStreamInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stream_switch.ProtoSubStreamInfo)
}

void ProtoSubStreamInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  index_ = 0;
  media_type_ = 0;
  codec_name_ = const_cast< ::std::string*>(_default_codec_name_);
  direction_ = 0;
  extra_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  height_ = 0u;
  width_ = 0u;
  fps_ = 0u;
  gov_ = 0u;
  samples_per_second_ = 0u;
  channels_ = 0u;
  bits_per_sample_ = 0u;
  sampele_per_frame_ = 0u;
  x_ = 0u;
  y_ = 0u;
  fone_size_ = 0u;
  font_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProtoSubStreamInfo::~ProtoSubStreamInfo() {
  // @@protoc_insertion_point(destructor:stream_switch.ProtoSubStreamInfo)
  SharedDtor();
}

void ProtoSubStreamInfo::SharedDtor() {
  if (codec_name_ != _default_codec_name_) {
    delete codec_name_;
  }
  if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_data_;
  }
  if (font_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete font_type_;
  }
  if (this != default_instance_) {
  }
}

void ProtoSubStreamInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProtoSubStreamInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtoSubStreamInfo_descriptor_;
}

const ProtoSubStreamInfo& ProtoSubStreamInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pb_5fmetadata_2eproto();
  return *default_instance_;
}

ProtoSubStreamInfo* ProtoSubStreamInfo::default_instance_ = NULL;

ProtoSubStreamInfo* ProtoSubStreamInfo::New() const {
  return new ProtoSubStreamInfo;
}

void ProtoSubStreamInfo::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ProtoSubStreamInfo*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(index_, media_type_);
    ZR_(direction_, fps_);
    if (has_codec_name()) {
      if (codec_name_ != _default_codec_name_) {
        codec_name_->assign(*_default_codec_name_);
      }
    }
    if (has_extra_data()) {
      if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        extra_data_->clear();
      }
    }
  }
  if (_has_bits_[8 / 32] & 65280) {
    ZR_(gov_, fone_size_);
  }
  if (has_font_type()) {
    if (font_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      font_type_->clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProtoSubStreamInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stream_switch.ProtoSubStreamInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_media_type;
        break;
      }

      // optional .stream_switch.ProtoSubStreamMediaType media_type = 2;
      case 2: {
        if (tag == 16) {
         parse_media_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::stream_switch::ProtoSubStreamMediaType_IsValid(value)) {
            set_media_type(static_cast< ::stream_switch::ProtoSubStreamMediaType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_codec_name;
        break;
      }

      // optional string codec_name = 3 [default = "h264"];
      case 3: {
        if (tag == 26) {
         parse_codec_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_codec_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->codec_name().data(), this->codec_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "codec_name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_direction;
        break;
      }

      // optional .stream_switch.ProtoSubStreamDirectionType direction = 4;
      case 4: {
        if (tag == 32) {
         parse_direction:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::stream_switch::ProtoSubStreamDirectionType_IsValid(value)) {
            set_direction(static_cast< ::stream_switch::ProtoSubStreamDirectionType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_extra_data;
        break;
      }

      // optional bytes extra_data = 10;
      case 10: {
        if (tag == 82) {
         parse_extra_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_extra_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_height;
        break;
      }

      // optional uint32 height = 20;
      case 20: {
        if (tag == 160) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_width;
        break;
      }

      // optional uint32 width = 21;
      case 21: {
        if (tag == 168) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_fps;
        break;
      }

      // optional uint32 fps = 22;
      case 22: {
        if (tag == 176) {
         parse_fps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fps_)));
          set_has_fps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_gov;
        break;
      }

      // optional uint32 gov = 23;
      case 23: {
        if (tag == 184) {
         parse_gov:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &gov_)));
          set_has_gov();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_samples_per_second;
        break;
      }

      // optional uint32 samples_per_second = 30;
      case 30: {
        if (tag == 240) {
         parse_samples_per_second:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &samples_per_second_)));
          set_has_samples_per_second();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_channels;
        break;
      }

      // optional uint32 channels = 31;
      case 31: {
        if (tag == 248) {
         parse_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &channels_)));
          set_has_channels();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_bits_per_sample;
        break;
      }

      // optional uint32 bits_per_sample = 32;
      case 32: {
        if (tag == 256) {
         parse_bits_per_sample:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bits_per_sample_)));
          set_has_bits_per_sample();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_sampele_per_frame;
        break;
      }

      // optional uint32 sampele_per_frame = 33;
      case 33: {
        if (tag == 264) {
         parse_sampele_per_frame:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sampele_per_frame_)));
          set_has_sampele_per_frame();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(320)) goto parse_x;
        break;
      }

      // optional uint32 x = 40;
      case 40: {
        if (tag == 320) {
         parse_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_y;
        break;
      }

      // optional uint32 y = 41;
      case 41: {
        if (tag == 328) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(336)) goto parse_fone_size;
        break;
      }

      // optional uint32 fone_size = 42;
      case 42: {
        if (tag == 336) {
         parse_fone_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &fone_size_)));
          set_has_fone_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(346)) goto parse_font_type;
        break;
      }

      // optional string font_type = 43;
      case 43: {
        if (tag == 346) {
         parse_font_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_font_type()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->font_type().data(), this->font_type().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "font_type");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stream_switch.ProtoSubStreamInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stream_switch.ProtoSubStreamInfo)
  return false;
#undef DO_
}

void ProtoSubStreamInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stream_switch.ProtoSubStreamInfo)
  // optional int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional .stream_switch.ProtoSubStreamMediaType media_type = 2;
  if (has_media_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->media_type(), output);
  }

  // optional string codec_name = 3 [default = "h264"];
  if (has_codec_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->codec_name().data(), this->codec_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "codec_name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->codec_name(), output);
  }

  // optional .stream_switch.ProtoSubStreamDirectionType direction = 4;
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->direction(), output);
  }

  // optional bytes extra_data = 10;
  if (has_extra_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      10, this->extra_data(), output);
  }

  // optional uint32 height = 20;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(20, this->height(), output);
  }

  // optional uint32 width = 21;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(21, this->width(), output);
  }

  // optional uint32 fps = 22;
  if (has_fps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(22, this->fps(), output);
  }

  // optional uint32 gov = 23;
  if (has_gov()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(23, this->gov(), output);
  }

  // optional uint32 samples_per_second = 30;
  if (has_samples_per_second()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(30, this->samples_per_second(), output);
  }

  // optional uint32 channels = 31;
  if (has_channels()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->channels(), output);
  }

  // optional uint32 bits_per_sample = 32;
  if (has_bits_per_sample()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(32, this->bits_per_sample(), output);
  }

  // optional uint32 sampele_per_frame = 33;
  if (has_sampele_per_frame()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(33, this->sampele_per_frame(), output);
  }

  // optional uint32 x = 40;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(40, this->x(), output);
  }

  // optional uint32 y = 41;
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(41, this->y(), output);
  }

  // optional uint32 fone_size = 42;
  if (has_fone_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(42, this->fone_size(), output);
  }

  // optional string font_type = 43;
  if (has_font_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->font_type().data(), this->font_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "font_type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      43, this->font_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stream_switch.ProtoSubStreamInfo)
}

::google::protobuf::uint8* ProtoSubStreamInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stream_switch.ProtoSubStreamInfo)
  // optional int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional .stream_switch.ProtoSubStreamMediaType media_type = 2;
  if (has_media_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->media_type(), target);
  }

  // optional string codec_name = 3 [default = "h264"];
  if (has_codec_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->codec_name().data(), this->codec_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "codec_name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->codec_name(), target);
  }

  // optional .stream_switch.ProtoSubStreamDirectionType direction = 4;
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->direction(), target);
  }

  // optional bytes extra_data = 10;
  if (has_extra_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->extra_data(), target);
  }

  // optional uint32 height = 20;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(20, this->height(), target);
  }

  // optional uint32 width = 21;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(21, this->width(), target);
  }

  // optional uint32 fps = 22;
  if (has_fps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(22, this->fps(), target);
  }

  // optional uint32 gov = 23;
  if (has_gov()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(23, this->gov(), target);
  }

  // optional uint32 samples_per_second = 30;
  if (has_samples_per_second()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(30, this->samples_per_second(), target);
  }

  // optional uint32 channels = 31;
  if (has_channels()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(31, this->channels(), target);
  }

  // optional uint32 bits_per_sample = 32;
  if (has_bits_per_sample()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(32, this->bits_per_sample(), target);
  }

  // optional uint32 sampele_per_frame = 33;
  if (has_sampele_per_frame()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(33, this->sampele_per_frame(), target);
  }

  // optional uint32 x = 40;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(40, this->x(), target);
  }

  // optional uint32 y = 41;
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(41, this->y(), target);
  }

  // optional uint32 fone_size = 42;
  if (has_fone_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(42, this->fone_size(), target);
  }

  // optional string font_type = 43;
  if (has_font_type()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->font_type().data(), this->font_type().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "font_type");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        43, this->font_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stream_switch.ProtoSubStreamInfo)
  return target;
}

int ProtoSubStreamInfo::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional .stream_switch.ProtoSubStreamMediaType media_type = 2;
    if (has_media_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->media_type());
    }

    // optional string codec_name = 3 [default = "h264"];
    if (has_codec_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->codec_name());
    }

    // optional .stream_switch.ProtoSubStreamDirectionType direction = 4;
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->direction());
    }

    // optional bytes extra_data = 10;
    if (has_extra_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->extra_data());
    }

    // optional uint32 height = 20;
    if (has_height()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->height());
    }

    // optional uint32 width = 21;
    if (has_width()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->width());
    }

    // optional uint32 fps = 22;
    if (has_fps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fps());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional uint32 gov = 23;
    if (has_gov()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->gov());
    }

    // optional uint32 samples_per_second = 30;
    if (has_samples_per_second()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->samples_per_second());
    }

    // optional uint32 channels = 31;
    if (has_channels()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->channels());
    }

    // optional uint32 bits_per_sample = 32;
    if (has_bits_per_sample()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bits_per_sample());
    }

    // optional uint32 sampele_per_frame = 33;
    if (has_sampele_per_frame()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sampele_per_frame());
    }

    // optional uint32 x = 40;
    if (has_x()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->x());
    }

    // optional uint32 y = 41;
    if (has_y()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->y());
    }

    // optional uint32 fone_size = 42;
    if (has_fone_size()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->fone_size());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional string font_type = 43;
    if (has_font_type()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->font_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProtoSubStreamInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProtoSubStreamInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProtoSubStreamInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProtoSubStreamInfo::MergeFrom(const ProtoSubStreamInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_media_type()) {
      set_media_type(from.media_type());
    }
    if (from.has_codec_name()) {
      set_codec_name(from.codec_name());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
    if (from.has_extra_data()) {
      set_extra_data(from.extra_data());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_fps()) {
      set_fps(from.fps());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_gov()) {
      set_gov(from.gov());
    }
    if (from.has_samples_per_second()) {
      set_samples_per_second(from.samples_per_second());
    }
    if (from.has_channels()) {
      set_channels(from.channels());
    }
    if (from.has_bits_per_sample()) {
      set_bits_per_sample(from.bits_per_sample());
    }
    if (from.has_sampele_per_frame()) {
      set_sampele_per_frame(from.sampele_per_frame());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_fone_size()) {
      set_fone_size(from.fone_size());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_font_type()) {
      set_font_type(from.font_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProtoSubStreamInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProtoSubStreamInfo::CopyFrom(const ProtoSubStreamInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoSubStreamInfo::IsInitialized() const {

  return true;
}

void ProtoSubStreamInfo::Swap(ProtoSubStreamInfo* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(media_type_, other->media_type_);
    std::swap(codec_name_, other->codec_name_);
    std::swap(direction_, other->direction_);
    std::swap(extra_data_, other->extra_data_);
    std::swap(height_, other->height_);
    std::swap(width_, other->width_);
    std::swap(fps_, other->fps_);
    std::swap(gov_, other->gov_);
    std::swap(samples_per_second_, other->samples_per_second_);
    std::swap(channels_, other->channels_);
    std::swap(bits_per_sample_, other->bits_per_sample_);
    std::swap(sampele_per_frame_, other->sampele_per_frame_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(fone_size_, other->fone_size_);
    std::swap(font_type_, other->font_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProtoSubStreamInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProtoSubStreamInfo_descriptor_;
  metadata.reflection = ProtoSubStreamInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

ProtoMetaReq::ProtoMetaReq()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stream_switch.ProtoMetaReq)
}

void ProtoMetaReq::InitAsDefaultInstance() {
}

ProtoMetaReq::ProtoMetaReq(const ProtoMetaReq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stream_switch.ProtoMetaReq)
}

void ProtoMetaReq::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProtoMetaReq::~ProtoMetaReq() {
  // @@protoc_insertion_point(destructor:stream_switch.ProtoMetaReq)
  SharedDtor();
}

void ProtoMetaReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProtoMetaReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProtoMetaReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtoMetaReq_descriptor_;
}

const ProtoMetaReq& ProtoMetaReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pb_5fmetadata_2eproto();
  return *default_instance_;
}

ProtoMetaReq* ProtoMetaReq::default_instance_ = NULL;

ProtoMetaReq* ProtoMetaReq::New() const {
  return new ProtoMetaReq;
}

void ProtoMetaReq::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProtoMetaReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stream_switch.ProtoMetaReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:stream_switch.ProtoMetaReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stream_switch.ProtoMetaReq)
  return false;
#undef DO_
}

void ProtoMetaReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stream_switch.ProtoMetaReq)
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stream_switch.ProtoMetaReq)
}

::google::protobuf::uint8* ProtoMetaReq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stream_switch.ProtoMetaReq)
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stream_switch.ProtoMetaReq)
  return target;
}

int ProtoMetaReq::ByteSize() const {
  int total_size = 0;

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProtoMetaReq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProtoMetaReq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProtoMetaReq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProtoMetaReq::MergeFrom(const ProtoMetaReq& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProtoMetaReq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProtoMetaReq::CopyFrom(const ProtoMetaReq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoMetaReq::IsInitialized() const {

  return true;
}

void ProtoMetaReq::Swap(ProtoMetaReq* other) {
  if (other != this) {
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProtoMetaReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProtoMetaReq_descriptor_;
  metadata.reflection = ProtoMetaReq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProtoMetaRep::kPlayTypeFieldNumber;
const int ProtoMetaRep::kSourceProtoFieldNumber;
const int ProtoMetaRep::kSsrcFieldNumber;
const int ProtoMetaRep::kBpsFieldNumber;
const int ProtoMetaRep::kSubStreamsFieldNumber;
#endif  // !_MSC_VER

ProtoMetaRep::ProtoMetaRep()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:stream_switch.ProtoMetaRep)
}

void ProtoMetaRep::InitAsDefaultInstance() {
}

ProtoMetaRep::ProtoMetaRep(const ProtoMetaRep& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:stream_switch.ProtoMetaRep)
}

void ProtoMetaRep::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  play_type_ = 0;
  source_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ssrc_ = 0u;
  bps_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProtoMetaRep::~ProtoMetaRep() {
  // @@protoc_insertion_point(destructor:stream_switch.ProtoMetaRep)
  SharedDtor();
}

void ProtoMetaRep::SharedDtor() {
  if (source_proto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_proto_;
  }
  if (this != default_instance_) {
  }
}

void ProtoMetaRep::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProtoMetaRep::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProtoMetaRep_descriptor_;
}

const ProtoMetaRep& ProtoMetaRep::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_pb_5fmetadata_2eproto();
  return *default_instance_;
}

ProtoMetaRep* ProtoMetaRep::default_instance_ = NULL;

ProtoMetaRep* ProtoMetaRep::New() const {
  return new ProtoMetaRep;
}

void ProtoMetaRep::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ProtoMetaRep*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(play_type_, ssrc_);
    if (has_source_proto()) {
      if (source_proto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        source_proto_->clear();
      }
    }
    bps_ = 0u;
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  sub_streams_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProtoMetaRep::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:stream_switch.ProtoMetaRep)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .stream_switch.ProtoPlayType play_type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::stream_switch::ProtoPlayType_IsValid(value)) {
            set_play_type(static_cast< ::stream_switch::ProtoPlayType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_source_proto;
        break;
      }

      // optional string source_proto = 2;
      case 2: {
        if (tag == 18) {
         parse_source_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source_proto()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->source_proto().data(), this->source_proto().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "source_proto");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_ssrc;
        break;
      }

      // optional uint32 ssrc = 3;
      case 3: {
        if (tag == 24) {
         parse_ssrc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ssrc_)));
          set_has_ssrc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_bps;
        break;
      }

      // optional uint32 bps = 4;
      case 4: {
        if (tag == 32) {
         parse_bps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &bps_)));
          set_has_bps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(514)) goto parse_sub_streams;
        break;
      }

      // repeated .stream_switch.ProtoSubStreamInfo sub_streams = 64;
      case 64: {
        if (tag == 514) {
         parse_sub_streams:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_sub_streams()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(514)) goto parse_sub_streams;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:stream_switch.ProtoMetaRep)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:stream_switch.ProtoMetaRep)
  return false;
#undef DO_
}

void ProtoMetaRep::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:stream_switch.ProtoMetaRep)
  // optional .stream_switch.ProtoPlayType play_type = 1;
  if (has_play_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->play_type(), output);
  }

  // optional string source_proto = 2;
  if (has_source_proto()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source_proto().data(), this->source_proto().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source_proto");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->source_proto(), output);
  }

  // optional uint32 ssrc = 3;
  if (has_ssrc()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->ssrc(), output);
  }

  // optional uint32 bps = 4;
  if (has_bps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->bps(), output);
  }

  // repeated .stream_switch.ProtoSubStreamInfo sub_streams = 64;
  for (int i = 0; i < this->sub_streams_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      64, this->sub_streams(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:stream_switch.ProtoMetaRep)
}

::google::protobuf::uint8* ProtoMetaRep::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:stream_switch.ProtoMetaRep)
  // optional .stream_switch.ProtoPlayType play_type = 1;
  if (has_play_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->play_type(), target);
  }

  // optional string source_proto = 2;
  if (has_source_proto()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source_proto().data(), this->source_proto().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "source_proto");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->source_proto(), target);
  }

  // optional uint32 ssrc = 3;
  if (has_ssrc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->ssrc(), target);
  }

  // optional uint32 bps = 4;
  if (has_bps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->bps(), target);
  }

  // repeated .stream_switch.ProtoSubStreamInfo sub_streams = 64;
  for (int i = 0; i < this->sub_streams_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        64, this->sub_streams(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:stream_switch.ProtoMetaRep)
  return target;
}

int ProtoMetaRep::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .stream_switch.ProtoPlayType play_type = 1;
    if (has_play_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->play_type());
    }

    // optional string source_proto = 2;
    if (has_source_proto()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source_proto());
    }

    // optional uint32 ssrc = 3;
    if (has_ssrc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->ssrc());
    }

    // optional uint32 bps = 4;
    if (has_bps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->bps());
    }

  }
  // repeated .stream_switch.ProtoSubStreamInfo sub_streams = 64;
  total_size += 2 * this->sub_streams_size();
  for (int i = 0; i < this->sub_streams_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->sub_streams(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProtoMetaRep::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProtoMetaRep* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProtoMetaRep*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProtoMetaRep::MergeFrom(const ProtoMetaRep& from) {
  GOOGLE_CHECK_NE(&from, this);
  sub_streams_.MergeFrom(from.sub_streams_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_play_type()) {
      set_play_type(from.play_type());
    }
    if (from.has_source_proto()) {
      set_source_proto(from.source_proto());
    }
    if (from.has_ssrc()) {
      set_ssrc(from.ssrc());
    }
    if (from.has_bps()) {
      set_bps(from.bps());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProtoMetaRep::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProtoMetaRep::CopyFrom(const ProtoMetaRep& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoMetaRep::IsInitialized() const {

  return true;
}

void ProtoMetaRep::Swap(ProtoMetaRep* other) {
  if (other != this) {
    std::swap(play_type_, other->play_type_);
    std::swap(source_proto_, other->source_proto_);
    std::swap(ssrc_, other->ssrc_);
    std::swap(bps_, other->bps_);
    sub_streams_.Swap(&other->sub_streams_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProtoMetaRep::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProtoMetaRep_descriptor_;
  metadata.reflection = ProtoMetaRep_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace stream_switch

// @@protoc_insertion_point(global_scope)

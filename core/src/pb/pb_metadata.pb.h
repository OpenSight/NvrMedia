// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pb_metadata.proto

#ifndef PROTOBUF_pb_5fmetadata_2eproto__INCLUDED
#define PROTOBUF_pb_5fmetadata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace stream_switch {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pb_5fmetadata_2eproto();
void protobuf_AssignDesc_pb_5fmetadata_2eproto();
void protobuf_ShutdownFile_pb_5fmetadata_2eproto();

class ProtoSubStreamInfo;
class ProtoMetaReq;
class ProtoMetaRep;

enum ProtoPlayType {
  PROTO_PLAY_TYPE_LIVE = 0,
  PROTO_PLAY_TYPE_REPLAY = 1
};
bool ProtoPlayType_IsValid(int value);
const ProtoPlayType ProtoPlayType_MIN = PROTO_PLAY_TYPE_LIVE;
const ProtoPlayType ProtoPlayType_MAX = PROTO_PLAY_TYPE_REPLAY;
const int ProtoPlayType_ARRAYSIZE = ProtoPlayType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtoPlayType_descriptor();
inline const ::std::string& ProtoPlayType_Name(ProtoPlayType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtoPlayType_descriptor(), value);
}
inline bool ProtoPlayType_Parse(
    const ::std::string& name, ProtoPlayType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtoPlayType>(
    ProtoPlayType_descriptor(), name, value);
}
enum ProtoSubStreamMediaType {
  PROTO_SUB_STREAM_MEIDA_TYPE_VIDEO = 0,
  PROTO_SUB_STREAM_MEIDA_TYPE_AUDIO = 1,
  PROTO_SUB_STREAM_MEIDA_TYPE_TEXT = 2,
  PROTO_SUB_STREAM_MEIDA_TYPE_PRIVATE = 3
};
bool ProtoSubStreamMediaType_IsValid(int value);
const ProtoSubStreamMediaType ProtoSubStreamMediaType_MIN = PROTO_SUB_STREAM_MEIDA_TYPE_VIDEO;
const ProtoSubStreamMediaType ProtoSubStreamMediaType_MAX = PROTO_SUB_STREAM_MEIDA_TYPE_PRIVATE;
const int ProtoSubStreamMediaType_ARRAYSIZE = ProtoSubStreamMediaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtoSubStreamMediaType_descriptor();
inline const ::std::string& ProtoSubStreamMediaType_Name(ProtoSubStreamMediaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtoSubStreamMediaType_descriptor(), value);
}
inline bool ProtoSubStreamMediaType_Parse(
    const ::std::string& name, ProtoSubStreamMediaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtoSubStreamMediaType>(
    ProtoSubStreamMediaType_descriptor(), name, value);
}
// ===================================================================

class ProtoSubStreamInfo : public ::google::protobuf::Message {
 public:
  ProtoSubStreamInfo();
  virtual ~ProtoSubStreamInfo();

  ProtoSubStreamInfo(const ProtoSubStreamInfo& from);

  inline ProtoSubStreamInfo& operator=(const ProtoSubStreamInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoSubStreamInfo& default_instance();

  void Swap(ProtoSubStreamInfo* other);

  // implements Message ----------------------------------------------

  ProtoSubStreamInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoSubStreamInfo& from);
  void MergeFrom(const ProtoSubStreamInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 sub_stream_index = 1;
  inline bool has_sub_stream_index() const;
  inline void clear_sub_stream_index();
  static const int kSubStreamIndexFieldNumber = 1;
  inline ::google::protobuf::int32 sub_stream_index() const;
  inline void set_sub_stream_index(::google::protobuf::int32 value);

  // optional .stream_switch.ProtoSubStreamMediaType media_type = 2;
  inline bool has_media_type() const;
  inline void clear_media_type();
  static const int kMediaTypeFieldNumber = 2;
  inline ::stream_switch::ProtoSubStreamMediaType media_type() const;
  inline void set_media_type(::stream_switch::ProtoSubStreamMediaType value);

  // optional string codec_name = 3 [default = "h264"];
  inline bool has_codec_name() const;
  inline void clear_codec_name();
  static const int kCodecNameFieldNumber = 3;
  inline const ::std::string& codec_name() const;
  inline void set_codec_name(const ::std::string& value);
  inline void set_codec_name(const char* value);
  inline void set_codec_name(const char* value, size_t size);
  inline ::std::string* mutable_codec_name();
  inline ::std::string* release_codec_name();
  inline void set_allocated_codec_name(::std::string* codec_name);

  // optional bytes extra_data = 4;
  inline bool has_extra_data() const;
  inline void clear_extra_data();
  static const int kExtraDataFieldNumber = 4;
  inline const ::std::string& extra_data() const;
  inline void set_extra_data(const ::std::string& value);
  inline void set_extra_data(const char* value);
  inline void set_extra_data(const void* value, size_t size);
  inline ::std::string* mutable_extra_data();
  inline ::std::string* release_extra_data();
  inline void set_allocated_extra_data(::std::string* extra_data);

  // optional uint32 height = 20;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 20;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional uint32 width = 21;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 21;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional uint32 fps = 22;
  inline bool has_fps() const;
  inline void clear_fps();
  static const int kFpsFieldNumber = 22;
  inline ::google::protobuf::uint32 fps() const;
  inline void set_fps(::google::protobuf::uint32 value);

  // optional uint32 gov = 23;
  inline bool has_gov() const;
  inline void clear_gov();
  static const int kGovFieldNumber = 23;
  inline ::google::protobuf::uint32 gov() const;
  inline void set_gov(::google::protobuf::uint32 value);

  // optional uint32 samples_per_second = 30;
  inline bool has_samples_per_second() const;
  inline void clear_samples_per_second();
  static const int kSamplesPerSecondFieldNumber = 30;
  inline ::google::protobuf::uint32 samples_per_second() const;
  inline void set_samples_per_second(::google::protobuf::uint32 value);

  // optional uint32 channels = 31;
  inline bool has_channels() const;
  inline void clear_channels();
  static const int kChannelsFieldNumber = 31;
  inline ::google::protobuf::uint32 channels() const;
  inline void set_channels(::google::protobuf::uint32 value);

  // optional uint32 bits_per_sample = 32;
  inline bool has_bits_per_sample() const;
  inline void clear_bits_per_sample();
  static const int kBitsPerSampleFieldNumber = 32;
  inline ::google::protobuf::uint32 bits_per_sample() const;
  inline void set_bits_per_sample(::google::protobuf::uint32 value);

  // optional uint32 x = 40;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 40;
  inline ::google::protobuf::uint32 x() const;
  inline void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 41;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 41;
  inline ::google::protobuf::uint32 y() const;
  inline void set_y(::google::protobuf::uint32 value);

  // optional uint32 size = 42;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 42;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional string font = 43;
  inline bool has_font() const;
  inline void clear_font();
  static const int kFontFieldNumber = 43;
  inline const ::std::string& font() const;
  inline void set_font(const ::std::string& value);
  inline void set_font(const char* value);
  inline void set_font(const char* value, size_t size);
  inline ::std::string* mutable_font();
  inline ::std::string* release_font();
  inline void set_allocated_font(::std::string* font);

  // @@protoc_insertion_point(class_scope:stream_switch.ProtoSubStreamInfo)
 private:
  inline void set_has_sub_stream_index();
  inline void clear_has_sub_stream_index();
  inline void set_has_media_type();
  inline void clear_has_media_type();
  inline void set_has_codec_name();
  inline void clear_has_codec_name();
  inline void set_has_extra_data();
  inline void clear_has_extra_data();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_fps();
  inline void clear_has_fps();
  inline void set_has_gov();
  inline void clear_has_gov();
  inline void set_has_samples_per_second();
  inline void clear_has_samples_per_second();
  inline void set_has_channels();
  inline void clear_has_channels();
  inline void set_has_bits_per_sample();
  inline void clear_has_bits_per_sample();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_font();
  inline void clear_has_font();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 sub_stream_index_;
  int media_type_;
  static ::std::string* _default_codec_name_;
  ::std::string* codec_name_;
  ::std::string* extra_data_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 fps_;
  ::google::protobuf::uint32 gov_;
  ::google::protobuf::uint32 samples_per_second_;
  ::google::protobuf::uint32 channels_;
  ::google::protobuf::uint32 bits_per_sample_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 size_;
  ::std::string* font_;
  friend void  protobuf_AddDesc_pb_5fmetadata_2eproto();
  friend void protobuf_AssignDesc_pb_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_pb_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static ProtoSubStreamInfo* default_instance_;
};
// -------------------------------------------------------------------

class ProtoMetaReq : public ::google::protobuf::Message {
 public:
  ProtoMetaReq();
  virtual ~ProtoMetaReq();

  ProtoMetaReq(const ProtoMetaReq& from);

  inline ProtoMetaReq& operator=(const ProtoMetaReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMetaReq& default_instance();

  void Swap(ProtoMetaReq* other);

  // implements Message ----------------------------------------------

  ProtoMetaReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMetaReq& from);
  void MergeFrom(const ProtoMetaReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:stream_switch.ProtoMetaReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_pb_5fmetadata_2eproto();
  friend void protobuf_AssignDesc_pb_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_pb_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static ProtoMetaReq* default_instance_;
};
// -------------------------------------------------------------------

class ProtoMetaRep : public ::google::protobuf::Message {
 public:
  ProtoMetaRep();
  virtual ~ProtoMetaRep();

  ProtoMetaRep(const ProtoMetaRep& from);

  inline ProtoMetaRep& operator=(const ProtoMetaRep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoMetaRep& default_instance();

  void Swap(ProtoMetaRep* other);

  // implements Message ----------------------------------------------

  ProtoMetaRep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProtoMetaRep& from);
  void MergeFrom(const ProtoMetaRep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .stream_switch.ProtoPlayType play_type = 1;
  inline bool has_play_type() const;
  inline void clear_play_type();
  static const int kPlayTypeFieldNumber = 1;
  inline ::stream_switch::ProtoPlayType play_type() const;
  inline void set_play_type(::stream_switch::ProtoPlayType value);

  // optional string source_proto = 2;
  inline bool has_source_proto() const;
  inline void clear_source_proto();
  static const int kSourceProtoFieldNumber = 2;
  inline const ::std::string& source_proto() const;
  inline void set_source_proto(const ::std::string& value);
  inline void set_source_proto(const char* value);
  inline void set_source_proto(const char* value, size_t size);
  inline ::std::string* mutable_source_proto();
  inline ::std::string* release_source_proto();
  inline void set_allocated_source_proto(::std::string* source_proto);

  // optional uint32 ssrc = 3;
  inline bool has_ssrc() const;
  inline void clear_ssrc();
  static const int kSsrcFieldNumber = 3;
  inline ::google::protobuf::uint32 ssrc() const;
  inline void set_ssrc(::google::protobuf::uint32 value);

  // optional uint32 bps = 4;
  inline bool has_bps() const;
  inline void clear_bps();
  static const int kBpsFieldNumber = 4;
  inline ::google::protobuf::uint32 bps() const;
  inline void set_bps(::google::protobuf::uint32 value);

  // repeated .stream_switch.ProtoSubStreamInfo sub_streams = 64;
  inline int sub_streams_size() const;
  inline void clear_sub_streams();
  static const int kSubStreamsFieldNumber = 64;
  inline const ::stream_switch::ProtoSubStreamInfo& sub_streams(int index) const;
  inline ::stream_switch::ProtoSubStreamInfo* mutable_sub_streams(int index);
  inline ::stream_switch::ProtoSubStreamInfo* add_sub_streams();
  inline const ::google::protobuf::RepeatedPtrField< ::stream_switch::ProtoSubStreamInfo >&
      sub_streams() const;
  inline ::google::protobuf::RepeatedPtrField< ::stream_switch::ProtoSubStreamInfo >*
      mutable_sub_streams();

  // @@protoc_insertion_point(class_scope:stream_switch.ProtoMetaRep)
 private:
  inline void set_has_play_type();
  inline void clear_has_play_type();
  inline void set_has_source_proto();
  inline void clear_has_source_proto();
  inline void set_has_ssrc();
  inline void clear_has_ssrc();
  inline void set_has_bps();
  inline void clear_has_bps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* source_proto_;
  int play_type_;
  ::google::protobuf::uint32 ssrc_;
  ::google::protobuf::RepeatedPtrField< ::stream_switch::ProtoSubStreamInfo > sub_streams_;
  ::google::protobuf::uint32 bps_;
  friend void  protobuf_AddDesc_pb_5fmetadata_2eproto();
  friend void protobuf_AssignDesc_pb_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_pb_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static ProtoMetaRep* default_instance_;
};
// ===================================================================


// ===================================================================

// ProtoSubStreamInfo

// optional int32 sub_stream_index = 1;
inline bool ProtoSubStreamInfo::has_sub_stream_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoSubStreamInfo::set_has_sub_stream_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoSubStreamInfo::clear_has_sub_stream_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoSubStreamInfo::clear_sub_stream_index() {
  sub_stream_index_ = 0;
  clear_has_sub_stream_index();
}
inline ::google::protobuf::int32 ProtoSubStreamInfo::sub_stream_index() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.sub_stream_index)
  return sub_stream_index_;
}
inline void ProtoSubStreamInfo::set_sub_stream_index(::google::protobuf::int32 value) {
  set_has_sub_stream_index();
  sub_stream_index_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.sub_stream_index)
}

// optional .stream_switch.ProtoSubStreamMediaType media_type = 2;
inline bool ProtoSubStreamInfo::has_media_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoSubStreamInfo::set_has_media_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoSubStreamInfo::clear_has_media_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoSubStreamInfo::clear_media_type() {
  media_type_ = 0;
  clear_has_media_type();
}
inline ::stream_switch::ProtoSubStreamMediaType ProtoSubStreamInfo::media_type() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.media_type)
  return static_cast< ::stream_switch::ProtoSubStreamMediaType >(media_type_);
}
inline void ProtoSubStreamInfo::set_media_type(::stream_switch::ProtoSubStreamMediaType value) {
  assert(::stream_switch::ProtoSubStreamMediaType_IsValid(value));
  set_has_media_type();
  media_type_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.media_type)
}

// optional string codec_name = 3 [default = "h264"];
inline bool ProtoSubStreamInfo::has_codec_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoSubStreamInfo::set_has_codec_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoSubStreamInfo::clear_has_codec_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoSubStreamInfo::clear_codec_name() {
  if (codec_name_ != _default_codec_name_) {
    codec_name_->assign(*_default_codec_name_);
  }
  clear_has_codec_name();
}
inline const ::std::string& ProtoSubStreamInfo::codec_name() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.codec_name)
  return *codec_name_;
}
inline void ProtoSubStreamInfo::set_codec_name(const ::std::string& value) {
  set_has_codec_name();
  if (codec_name_ == _default_codec_name_) {
    codec_name_ = new ::std::string;
  }
  codec_name_->assign(value);
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.codec_name)
}
inline void ProtoSubStreamInfo::set_codec_name(const char* value) {
  set_has_codec_name();
  if (codec_name_ == _default_codec_name_) {
    codec_name_ = new ::std::string;
  }
  codec_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:stream_switch.ProtoSubStreamInfo.codec_name)
}
inline void ProtoSubStreamInfo::set_codec_name(const char* value, size_t size) {
  set_has_codec_name();
  if (codec_name_ == _default_codec_name_) {
    codec_name_ = new ::std::string;
  }
  codec_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream_switch.ProtoSubStreamInfo.codec_name)
}
inline ::std::string* ProtoSubStreamInfo::mutable_codec_name() {
  set_has_codec_name();
  if (codec_name_ == _default_codec_name_) {
    codec_name_ = new ::std::string(*_default_codec_name_);
  }
  // @@protoc_insertion_point(field_mutable:stream_switch.ProtoSubStreamInfo.codec_name)
  return codec_name_;
}
inline ::std::string* ProtoSubStreamInfo::release_codec_name() {
  clear_has_codec_name();
  if (codec_name_ == _default_codec_name_) {
    return NULL;
  } else {
    ::std::string* temp = codec_name_;
    codec_name_ = const_cast< ::std::string*>(_default_codec_name_);
    return temp;
  }
}
inline void ProtoSubStreamInfo::set_allocated_codec_name(::std::string* codec_name) {
  if (codec_name_ != _default_codec_name_) {
    delete codec_name_;
  }
  if (codec_name) {
    set_has_codec_name();
    codec_name_ = codec_name;
  } else {
    clear_has_codec_name();
    codec_name_ = const_cast< ::std::string*>(_default_codec_name_);
  }
  // @@protoc_insertion_point(field_set_allocated:stream_switch.ProtoSubStreamInfo.codec_name)
}

// optional bytes extra_data = 4;
inline bool ProtoSubStreamInfo::has_extra_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoSubStreamInfo::set_has_extra_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoSubStreamInfo::clear_has_extra_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoSubStreamInfo::clear_extra_data() {
  if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_->clear();
  }
  clear_has_extra_data();
}
inline const ::std::string& ProtoSubStreamInfo::extra_data() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.extra_data)
  return *extra_data_;
}
inline void ProtoSubStreamInfo::set_extra_data(const ::std::string& value) {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  extra_data_->assign(value);
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.extra_data)
}
inline void ProtoSubStreamInfo::set_extra_data(const char* value) {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  extra_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:stream_switch.ProtoSubStreamInfo.extra_data)
}
inline void ProtoSubStreamInfo::set_extra_data(const void* value, size_t size) {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  extra_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream_switch.ProtoSubStreamInfo.extra_data)
}
inline ::std::string* ProtoSubStreamInfo::mutable_extra_data() {
  set_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    extra_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:stream_switch.ProtoSubStreamInfo.extra_data)
  return extra_data_;
}
inline ::std::string* ProtoSubStreamInfo::release_extra_data() {
  clear_has_extra_data();
  if (extra_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = extra_data_;
    extra_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoSubStreamInfo::set_allocated_extra_data(::std::string* extra_data) {
  if (extra_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete extra_data_;
  }
  if (extra_data) {
    set_has_extra_data();
    extra_data_ = extra_data;
  } else {
    clear_has_extra_data();
    extra_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:stream_switch.ProtoSubStreamInfo.extra_data)
}

// optional uint32 height = 20;
inline bool ProtoSubStreamInfo::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoSubStreamInfo::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoSubStreamInfo::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoSubStreamInfo::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::height() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.height)
  return height_;
}
inline void ProtoSubStreamInfo::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.height)
}

// optional uint32 width = 21;
inline bool ProtoSubStreamInfo::has_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoSubStreamInfo::set_has_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoSubStreamInfo::clear_has_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoSubStreamInfo::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::width() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.width)
  return width_;
}
inline void ProtoSubStreamInfo::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.width)
}

// optional uint32 fps = 22;
inline bool ProtoSubStreamInfo::has_fps() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoSubStreamInfo::set_has_fps() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoSubStreamInfo::clear_has_fps() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoSubStreamInfo::clear_fps() {
  fps_ = 0u;
  clear_has_fps();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::fps() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.fps)
  return fps_;
}
inline void ProtoSubStreamInfo::set_fps(::google::protobuf::uint32 value) {
  set_has_fps();
  fps_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.fps)
}

// optional uint32 gov = 23;
inline bool ProtoSubStreamInfo::has_gov() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoSubStreamInfo::set_has_gov() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoSubStreamInfo::clear_has_gov() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoSubStreamInfo::clear_gov() {
  gov_ = 0u;
  clear_has_gov();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::gov() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.gov)
  return gov_;
}
inline void ProtoSubStreamInfo::set_gov(::google::protobuf::uint32 value) {
  set_has_gov();
  gov_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.gov)
}

// optional uint32 samples_per_second = 30;
inline bool ProtoSubStreamInfo::has_samples_per_second() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoSubStreamInfo::set_has_samples_per_second() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtoSubStreamInfo::clear_has_samples_per_second() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtoSubStreamInfo::clear_samples_per_second() {
  samples_per_second_ = 0u;
  clear_has_samples_per_second();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::samples_per_second() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.samples_per_second)
  return samples_per_second_;
}
inline void ProtoSubStreamInfo::set_samples_per_second(::google::protobuf::uint32 value) {
  set_has_samples_per_second();
  samples_per_second_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.samples_per_second)
}

// optional uint32 channels = 31;
inline bool ProtoSubStreamInfo::has_channels() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProtoSubStreamInfo::set_has_channels() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProtoSubStreamInfo::clear_has_channels() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProtoSubStreamInfo::clear_channels() {
  channels_ = 0u;
  clear_has_channels();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::channels() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.channels)
  return channels_;
}
inline void ProtoSubStreamInfo::set_channels(::google::protobuf::uint32 value) {
  set_has_channels();
  channels_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.channels)
}

// optional uint32 bits_per_sample = 32;
inline bool ProtoSubStreamInfo::has_bits_per_sample() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProtoSubStreamInfo::set_has_bits_per_sample() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProtoSubStreamInfo::clear_has_bits_per_sample() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProtoSubStreamInfo::clear_bits_per_sample() {
  bits_per_sample_ = 0u;
  clear_has_bits_per_sample();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::bits_per_sample() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.bits_per_sample)
  return bits_per_sample_;
}
inline void ProtoSubStreamInfo::set_bits_per_sample(::google::protobuf::uint32 value) {
  set_has_bits_per_sample();
  bits_per_sample_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.bits_per_sample)
}

// optional uint32 x = 40;
inline bool ProtoSubStreamInfo::has_x() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProtoSubStreamInfo::set_has_x() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProtoSubStreamInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProtoSubStreamInfo::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::x() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.x)
  return x_;
}
inline void ProtoSubStreamInfo::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.x)
}

// optional uint32 y = 41;
inline bool ProtoSubStreamInfo::has_y() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProtoSubStreamInfo::set_has_y() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProtoSubStreamInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProtoSubStreamInfo::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::y() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.y)
  return y_;
}
inline void ProtoSubStreamInfo::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.y)
}

// optional uint32 size = 42;
inline bool ProtoSubStreamInfo::has_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProtoSubStreamInfo::set_has_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProtoSubStreamInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProtoSubStreamInfo::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 ProtoSubStreamInfo::size() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.size)
  return size_;
}
inline void ProtoSubStreamInfo::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.size)
}

// optional string font = 43;
inline bool ProtoSubStreamInfo::has_font() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProtoSubStreamInfo::set_has_font() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProtoSubStreamInfo::clear_has_font() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProtoSubStreamInfo::clear_font() {
  if (font_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_->clear();
  }
  clear_has_font();
}
inline const ::std::string& ProtoSubStreamInfo::font() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoSubStreamInfo.font)
  return *font_;
}
inline void ProtoSubStreamInfo::set_font(const ::std::string& value) {
  set_has_font();
  if (font_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_ = new ::std::string;
  }
  font_->assign(value);
  // @@protoc_insertion_point(field_set:stream_switch.ProtoSubStreamInfo.font)
}
inline void ProtoSubStreamInfo::set_font(const char* value) {
  set_has_font();
  if (font_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_ = new ::std::string;
  }
  font_->assign(value);
  // @@protoc_insertion_point(field_set_char:stream_switch.ProtoSubStreamInfo.font)
}
inline void ProtoSubStreamInfo::set_font(const char* value, size_t size) {
  set_has_font();
  if (font_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_ = new ::std::string;
  }
  font_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream_switch.ProtoSubStreamInfo.font)
}
inline ::std::string* ProtoSubStreamInfo::mutable_font() {
  set_has_font();
  if (font_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    font_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:stream_switch.ProtoSubStreamInfo.font)
  return font_;
}
inline ::std::string* ProtoSubStreamInfo::release_font() {
  clear_has_font();
  if (font_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = font_;
    font_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoSubStreamInfo::set_allocated_font(::std::string* font) {
  if (font_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete font_;
  }
  if (font) {
    set_has_font();
    font_ = font;
  } else {
    clear_has_font();
    font_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:stream_switch.ProtoSubStreamInfo.font)
}

// -------------------------------------------------------------------

// ProtoMetaReq

// -------------------------------------------------------------------

// ProtoMetaRep

// optional .stream_switch.ProtoPlayType play_type = 1;
inline bool ProtoMetaRep::has_play_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoMetaRep::set_has_play_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoMetaRep::clear_has_play_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoMetaRep::clear_play_type() {
  play_type_ = 0;
  clear_has_play_type();
}
inline ::stream_switch::ProtoPlayType ProtoMetaRep::play_type() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoMetaRep.play_type)
  return static_cast< ::stream_switch::ProtoPlayType >(play_type_);
}
inline void ProtoMetaRep::set_play_type(::stream_switch::ProtoPlayType value) {
  assert(::stream_switch::ProtoPlayType_IsValid(value));
  set_has_play_type();
  play_type_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoMetaRep.play_type)
}

// optional string source_proto = 2;
inline bool ProtoMetaRep::has_source_proto() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoMetaRep::set_has_source_proto() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoMetaRep::clear_has_source_proto() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoMetaRep::clear_source_proto() {
  if (source_proto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_proto_->clear();
  }
  clear_has_source_proto();
}
inline const ::std::string& ProtoMetaRep::source_proto() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoMetaRep.source_proto)
  return *source_proto_;
}
inline void ProtoMetaRep::set_source_proto(const ::std::string& value) {
  set_has_source_proto();
  if (source_proto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_proto_ = new ::std::string;
  }
  source_proto_->assign(value);
  // @@protoc_insertion_point(field_set:stream_switch.ProtoMetaRep.source_proto)
}
inline void ProtoMetaRep::set_source_proto(const char* value) {
  set_has_source_proto();
  if (source_proto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_proto_ = new ::std::string;
  }
  source_proto_->assign(value);
  // @@protoc_insertion_point(field_set_char:stream_switch.ProtoMetaRep.source_proto)
}
inline void ProtoMetaRep::set_source_proto(const char* value, size_t size) {
  set_has_source_proto();
  if (source_proto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_proto_ = new ::std::string;
  }
  source_proto_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:stream_switch.ProtoMetaRep.source_proto)
}
inline ::std::string* ProtoMetaRep::mutable_source_proto() {
  set_has_source_proto();
  if (source_proto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    source_proto_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:stream_switch.ProtoMetaRep.source_proto)
  return source_proto_;
}
inline ::std::string* ProtoMetaRep::release_source_proto() {
  clear_has_source_proto();
  if (source_proto_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = source_proto_;
    source_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ProtoMetaRep::set_allocated_source_proto(::std::string* source_proto) {
  if (source_proto_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete source_proto_;
  }
  if (source_proto) {
    set_has_source_proto();
    source_proto_ = source_proto;
  } else {
    clear_has_source_proto();
    source_proto_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:stream_switch.ProtoMetaRep.source_proto)
}

// optional uint32 ssrc = 3;
inline bool ProtoMetaRep::has_ssrc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoMetaRep::set_has_ssrc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoMetaRep::clear_has_ssrc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoMetaRep::clear_ssrc() {
  ssrc_ = 0u;
  clear_has_ssrc();
}
inline ::google::protobuf::uint32 ProtoMetaRep::ssrc() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoMetaRep.ssrc)
  return ssrc_;
}
inline void ProtoMetaRep::set_ssrc(::google::protobuf::uint32 value) {
  set_has_ssrc();
  ssrc_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoMetaRep.ssrc)
}

// optional uint32 bps = 4;
inline bool ProtoMetaRep::has_bps() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoMetaRep::set_has_bps() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoMetaRep::clear_has_bps() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoMetaRep::clear_bps() {
  bps_ = 0u;
  clear_has_bps();
}
inline ::google::protobuf::uint32 ProtoMetaRep::bps() const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoMetaRep.bps)
  return bps_;
}
inline void ProtoMetaRep::set_bps(::google::protobuf::uint32 value) {
  set_has_bps();
  bps_ = value;
  // @@protoc_insertion_point(field_set:stream_switch.ProtoMetaRep.bps)
}

// repeated .stream_switch.ProtoSubStreamInfo sub_streams = 64;
inline int ProtoMetaRep::sub_streams_size() const {
  return sub_streams_.size();
}
inline void ProtoMetaRep::clear_sub_streams() {
  sub_streams_.Clear();
}
inline const ::stream_switch::ProtoSubStreamInfo& ProtoMetaRep::sub_streams(int index) const {
  // @@protoc_insertion_point(field_get:stream_switch.ProtoMetaRep.sub_streams)
  return sub_streams_.Get(index);
}
inline ::stream_switch::ProtoSubStreamInfo* ProtoMetaRep::mutable_sub_streams(int index) {
  // @@protoc_insertion_point(field_mutable:stream_switch.ProtoMetaRep.sub_streams)
  return sub_streams_.Mutable(index);
}
inline ::stream_switch::ProtoSubStreamInfo* ProtoMetaRep::add_sub_streams() {
  // @@protoc_insertion_point(field_add:stream_switch.ProtoMetaRep.sub_streams)
  return sub_streams_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::stream_switch::ProtoSubStreamInfo >&
ProtoMetaRep::sub_streams() const {
  // @@protoc_insertion_point(field_list:stream_switch.ProtoMetaRep.sub_streams)
  return sub_streams_;
}
inline ::google::protobuf::RepeatedPtrField< ::stream_switch::ProtoSubStreamInfo >*
ProtoMetaRep::mutable_sub_streams() {
  // @@protoc_insertion_point(field_mutable_list:stream_switch.ProtoMetaRep.sub_streams)
  return &sub_streams_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace stream_switch

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::stream_switch::ProtoPlayType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::stream_switch::ProtoPlayType>() {
  return ::stream_switch::ProtoPlayType_descriptor();
}
template <> struct is_proto_enum< ::stream_switch::ProtoSubStreamMediaType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::stream_switch::ProtoSubStreamMediaType>() {
  return ::stream_switch::ProtoSubStreamMediaType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pb_5fmetadata_2eproto__INCLUDED
